

Generated markdown
# High-Performance Algorithm for Stack Permutations and k-th Retrieval

## Overview

This project presents a novel and computationally efficient C++ implementation for solving two fundamental problems in combinatorics and computer science:

1.  **Counting the number of stack-sortable permutations** for a given integer `n`, which is kind of similar to the famous n-th [Catalan number](https://en.wikipedia.org/wiki/Catalan_number).
2.  **Directly retrieving the k-th stack permutation** in lexicographical order without generating all permutations.

This work moves beyond naive brute-force solutions to tackle a unique problem, demonstrating a deep understanding of algorithms, dynamic programming, and computational optimization.

---

## The Core Problem

A permutation of the numbers `[1, 2, ..., n]` is considered "stack-sortable" if it can be generated by a sequence of push and pop operations on a single stack. Given an input sequence of `1, 2, ..., n`, we can either push the next number onto the stack or pop the top element from the stack to our output.

**Example:** For `n=3`, the output `[3, 1, 2]` is not possible, but `[1, 3, 2]` is.

While counting these permutations is a classic problem solved by Catalan numbers, the real challenge addressed here is **finding the k-th permutation directly.** A brute-force approach (generating all `C(n)` permutations and picking the k-th) is computationally infeasible for even moderately large `n`, as the Catalan numbers grow exponentially.

This project implements an efficient algorithm to construct the k-th permutation in approximately `O(n)` time, a dramatic improvement.

---

## Key Features

*   **Efficient Catalan Number Calculation:** Utilizes array of array to pre-compute Catalan numbers up to `n`, avoiding costly recursive re-computation.
*   **Direct k-th Permutation Retrieval:** Implements a sophisticated algorithm that constructs the desired permutation element by element, making intelligent choices based on `k`.
*   **High Performance:** Written in C with code converted to C++ with a focus on optimization, capable of handling large values of `n` that are only limited by the `long long int` data type(which you can bypass by makimg your own data type of storinh larger integers).
*   **Rigorously Tested:** Validated against a brute-force validator for smaller `n` and tested on a wide range of edge cases to ensure correctness.
*   **Limitatoins:** work well for n<=29, after that the long long int limit is hit. You can create your own data type and maybe see that code running fine even if n value is in thousands.

---

## The Algorithmic Approach

### Part 1: Preparing an array of array

We start with first array of lenth 1 and value 1. Subsequently in other array for `Aₙ[i]` we compute sum of `Aₙ₋₁[0]` to `Aₙ₋₁[i]` and finally the last element of the array will be same as second last(You will understand why i did this if you just write sttack permutations of some of first few natural numbers).


### Part 2: Formation of helping array
This helping array is based on the value of `k` and requires a sophisticated algorithm. This array contsains a particular combination of index values of the array of array we created earlier.

### Part 3: Formation of final array
The final array is based on the helping array and also requires a understanding of stack permutations pattern to see what actually is going on, but in simple terms we create our final array by carefully analyzing the indices presenjt in the helping array.


The decision is made by calculating how many permutations are "skipped" by choosing one path over the other.



## How to Compile and Run

```bash
# Clone the repository
git clone https://github.com/royaL171003/stack-permutations.git
cd stack-permutations

# Compile the source code
g++ -o run_stack_permute main stackcode.cpp

# Run the program
# The program will prompt for n and k
./run_stack_permute

# The program starts and asks for your input
Enter the value of n: 28
Enter the value of k: 1658648961

Testing Methodology

The correctness of the algorithm was ensured through a multi-faceted testing approach:

Unit Tests: Functions for Catalan numbers and the core retrieval logic were tested in isolation.

Brute-Force Validation: For small n (e.g., n <= 8), the output of this algorithm was compared against a complete list of permutations generated by a simple brute-force backtracking validator.

Edge Case Analysis: Tested for n=0, n=1, k=1 (the first permutation), and k=C(n) (the last permutation) to ensure robustness.

Generated code
By filling in the details of your approach, you will perfectly showcase your thought process, turning a simple code repository into a compelling story of your engineering talent.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END
